use std::{
    fmt::format,
    io::{prelude::*, BufRead, BufReader},
    net::TcpListener,
    str::FromStr,
    sync::{
        mpsc::{self, Receiver},
        Arc, Mutex,
    },
    thread,
};

use super::Server;

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        println!("Creating a new thread with the id {id}");

        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}

type Job = Box<dyn FnOnce() + Send + 'static>;

pub struct CoreServer
// TODO: uncomment this this
// <'a>
{
    // TODO: remove this
    host: String,

    // TODO: uncomment this
    // host: &'a str,

    // where to run this server;
    // normally its 80(http) and 443(https)
    port: u32,

    // this specifies the number of threads to be spawned
    thread_count: usize,
    // this holds the threads generated by the server
    pool: Option<Vec<Worker>>,

    sender: mpsc::Sender<Job>,

    // TODO: fix this type
    // receiver: mpsc::Receiver<Job>,

    // `Arc<Mutex<std::sync::mpsc::Receiver<Box<(dyn FnOnce() + Send + 'static)>>>>
    receiver: Arc<Mutex<Receiver<Job>>>,
}

impl Server for CoreServer {
    // step 1
    fn new(host: &str, port: u32, count: usize) -> CoreServer {
        println!("Starting the `rn` server... Hang on");

        println!("count is {}", count > 1);

        assert!(count > 1, "Thread count passed is less than 1. Quitting");

        let (sender, receiver) = mpsc::channel();

        CoreServer {
            thread_count: count,
            // host,

            // TODO: remove this
            host: String::from_str(host).unwrap(),
            port,
            pool: None,
            sender,
            receiver: Arc::new(Mutex::new(receiver)),
        }
    }

    // step 2
    // this step will create the threads
    fn create_threads(&mut self) {
        let mut thread_collector = Vec::with_capacity(
            self.thread_count, // 4,
        );

        let receiver = &self.receiver;

        for index in 0..self.thread_count {
            thread_collector.push(Worker::new(
                index.try_into().unwrap(),
                Arc::clone(&receiver),
            ))
        }

        self.pool = Some(thread_collector);
    }

    // should be step 3
    fn start(&self) -> TcpListener {
        println!("Server is now listening on ports 80 and 443");
        let complete_server_address: String = format!("127.0.0.1:{}", self.port);
        let server_binding = TcpListener::bind(complete_server_address).unwrap();
        server_binding
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}
